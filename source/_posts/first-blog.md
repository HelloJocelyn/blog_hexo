---
title: first_blog
---


## 线程安全性

### 原子性


* 竞态条件：当某个计算的正确性取决于多个线程的交替执行顺序时，那么就会发生竞态条件。常见的先检查后执行（Check-Then-Act).
	* 例子：非同步的单例模式
* 延迟初始化的竞态条件
* 复合操作


### 加锁机制

* 内置锁：作用于同步代码块（包括方法）的synchronized.
	作用于方法上时，锁为调用该方法的对象。作用于静态方法上时，锁为class对象。
* 重入：如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。
	* 重入的一种实现方式：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁被认为时没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并将计数值计为1.如果同一个线程再次获取这个锁，计数值递增。线程退出同步代码块时，计数器相应递减。计数值为0时，锁被释放。


### 用锁来保护状态

AbstractRefreshableApplicationContext的beanFactory


### 活跃性与性能




